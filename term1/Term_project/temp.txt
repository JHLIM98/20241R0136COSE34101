// 이전 makefile

# 컴파일러 설정
CC = gcc
#CFLAGS = -Wall -Wextra -std=c11

# 실행 파일 이름
TARGET = cpu_simulator

# 소스 파일들
SRCS = main.c process.c queue.c priority_queue.c result.c

# 오브젝트 파일들
OBJS = $(SRCS:.c=.o)

# 헤더 파일들
DEPS = process.h queue.h constant.h header.h priority_queue.h 

# 실행 파일 빌드 규칙
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) -o $@ $^

# 개별 소스 파일 컴파일 규칙
%.o: %.c $(DEPS)
	$(CC) $(CFLAGS) -c -o $@ $<

# clean 규칙
.PHONY: clean
clean:
	rm -f $(OBJS) $(TARGET)

.PHONY: run
run: $(TARGET)
	./$(TARGET)

# 헤더 파일 라인 수 계산
find . -name "*.h" -print0 | xargs -0 cat | wc -l

# 소스 파일 라인 수 계산
find . -name "*.c" -print0 | xargs -0 cat | wc -l



##############################################################################################################
##############################################################################################################

Test Code
//queue test
    Queue* ready_queue = init_Queue();

    for(int i = 0; i < PROCESS_COUNT; i++)
    {
        push_queue(ready_queue, p[i]);
    }

    print_queue(ready_queue);
    push_queue(ready_queue, p[0]);
    for(int i = 0; i < PROCESS_COUNT; i++) printf("pop : %d\n", pop_queue(ready_queue)->pid);

    //pq test
    PriorityQueue* waiting_queue = init_PriorityQueue(false);

    for(int i = 0; i < PROCESS_COUNT; i++)
    {
        push_pq(waiting_queue, p[i], p[i]->priority);
    }

    print_pq(waiting_queue);

    //result_ADT test
    result test_result;
    init_result(&test_result, "Test_result");

    executed_node node1 = {1, 0, 5, "Done"};
    executed_node node2 = {2, 5, 10, "IO"};
    executed_node node3 = {1, 10, 15, "Preempty"};

    record_result(&test_result, &node1);
    record_result(&test_result, &node2);
    record_result(&test_result, &node3);

    print_result(&test_result);



##############################################################################################################
##############################################################################################################


#include "../include/FCFS.h"


//void FCFS(Process* p[], result *res)
void FCFS(Process* p[])
{
    result FCFS_result;
    Queue* ready_queue;
    PriorityQueue* waiting_queue;
    Queue* run;
    Queue* done_queue;

    ready_queue = init_Queue();
    waiting_queue = init_PriorityQueue(true);
    done_queue = init_Queue();
    run = init_Queue();
    init_result(&FCFS_result, "FCFS RESULT");
    
    PriorityQueue* new_queue;
    new_queue = init_PriorityQueue(true);
    
    int idx = 0;
    for(int i = 0; i < PROCESS_COUNT; i++)
    {
        if (p[idx] == NULL) {
            printf("FCFS : NEW queue is done");
            break;
        }

        push_pq(new_queue, p[idx], p[idx]->arrived_time);
        idx++;
    } 

    print_pq(new_queue);

    int time = 0;

while (queue_size(done_queue) < PROCESS_COUNT)
{
    // ready queue section
    // new process
    while (!isEmpty_PQ(new_queue) && time >= front_pq(new_queue)->arrived_time)
    {
        //printf("new_front : %d\n", front_pq(new_queue)->pid);
        strcpy(front_pq(new_queue)->state, "ready");
        push_queue(ready_queue, pop_pq(new_queue));
        //print_queue(ready_queue);
        if (isEmpty_PQ(new_queue)) break;
    }
    // waiting process
    while (!isEmpty_PQ(waiting_queue) && front_pq(waiting_queue)->io_remain_time <= 0)
    {
        printf("wating End\n");
        strcpy(front_pq(waiting_queue)->state, "ready");
        if(strcmp(front_pq(waiting_queue)->type, "IO_bounded") == 0){
            front_pq(waiting_queue)->io_remain_time = front_pq(waiting_queue)->io_burst_time;
        }
        push_queue(ready_queue, pop_pq(waiting_queue));
    }
    
    //printf("ready is done\n");

    


    //
    // run section
    //

    // run new task
    if (isEmpty_queue(run) && !isEmpty_queue(ready_queue))
    {
        push_queue(run, pop_queue(ready_queue));
        strcpy(run->data[0]->state, "run");
        
        run->data[0]->resume_time = time;           // run 재개 시간

        if (run->data[0]->start_time == 0) {        // 최초 시작 시간
            run->data[0]->start_time = time;
        }

///*************
//        if(strcmp(run->data[0]->type, "IO_bounded") == 0)   //iobound 일경우 다시 인터럽 일어나도록
//        {
//            run->data[0]->io_remain_time = time; //현재 시간
//        }

///*************
    }

    //
    //

    // time increase
    time++;
    if (!isEmpty_queue(run))
        run->data[0]->remaining_time--;

    // complete
    if (!isEmpty_queue(run) && run->data[0]->remaining_time == 0)
    {
        strcpy(run->data[0]->state, "done");
        run->data[0]->complete_time = time;
        executed_node node1 = {run->data[0]->pid, run->data[0]->resume_time, run->data[0]->complete_time, "done"};

        record_result(&FCFS_result, &node1);
        push_queue(done_queue, pop_queue(run));

        //printf("done queue size : %d\n", queue_size(done_queue));
    }
    //cpu_bounded-> 1 interrupt
    if(!isEmpty_queue(run) && 
        strcmp(run->data[0]->type, "CPU_bounded") == 0 && 
        run->data[0]->io_interval == time - run->data[0]->resume_time &&
        run->data[0]->io_remain_time != 0)
        {
            printf("cpu bounded : preempted!\n");
            strcpy(run->data[0]->state, "waiting");
            
            executed_node node_wait = {run->data[0]->pid, run->data[0]->resume_time, time, "waiting"};
            record_result(&FCFS_result, &node_wait);
            push_pq(waiting_queue, pop_queue(run), run->data[0]->io_remain_time);
        }

    //IO_bounded-> steady interrupt
    if(!isEmpty_queue(run) &&
       strcmp(run->data[0]->type, "IO_bounded") == 0 &&
       run->data[0]->io_interval == time - run->data[0]->resume_time)        //io_remain_time = process restart or start time
       {
            printf("IO_bounded : preempted!\n");
            strcpy(run->data[0]->state, "waiting");
            executed_node node_wait = {run->data[0]->pid, run->data[0]->resume_time, time, "waiting"};
            record_result(&FCFS_result, &node_wait);

            //run->data[0]->io_remain_time = run->data[0]->io_interval;
            push_pq(waiting_queue, pop_queue(run), run->data[0]->io_remain_time);

       }
    //
    // run section : END
    //



    for (int i = ready_queue->front; i != ready_queue->rear + 1 && !isEmpty_queue(ready_queue); i = (i + 1) % QUEUE_SIZE)
    {
        ready_queue->data[i]->waiting_time++;
    }

    for (int i = 0; i <= waiting_queue->rear && !isEmpty_PQ(waiting_queue); i++)
    {
        waiting_queue->data[i]->io_remain_time--;
    }
}

print_result(&FCFS_result);

printf("\n\n*****FCFS is Done*****\n\n");
}






void print_gantt_chart(result *res) {
    int max_time = res->exe_node[res->node_count - 1].end_time;

    // PID별로 간트 차트 문자열을 생성하기 위한 배열
    pid_gantt *pid_gantts = malloc(res->node_count * sizeof(pid_gantt));
    int unique_pid_count = 0;

    // 각 PID별로 실행 시간을 수집
    for (int i = 0; i < res->node_count; i++) {
        executed_node node = res->exe_node[i];

        // 이미 존재하는 PID인지 확인
        int found = 0;
        for (int j = 0; j < unique_pid_count; j++) {
            if (pid_gantts[j].pid == node.pid) {
                found = 1;
                break;
            }
        }

        // 존재하지 않으면 새로운 PID 추가
        if (!found) {
            pid_gantts[unique_pid_count].pid = node.pid;
            pid_gantts[unique_pid_count].gantt = malloc((max_time + 1) * sizeof(char));
            for (int k = 0; k < max_time; k++) {
                pid_gantts[unique_pid_count].gantt[k] = ' ';
            }
            pid_gantts[unique_pid_count].gantt[max_time] = '\0';
            unique_pid_count++;
        }

        // 해당 PID의 간트 차트 문자열에 실행 시간 추가
        for (int j = 0; j < unique_pid_count; j++) {
            if (pid_gantts[j].pid == node.pid) {
                for (int t = node.start_time; t < node.end_time; t++) {
                    pid_gantts[j].gantt[t] = '■';
                }
                break;
            }
        }
    }

    // 각 PID별로 간트 차트를 출력
    for (int i = 0; i < unique_pid_count; i++) {
        printf("PID: %-5d |%s| %d - %d\n", pid_gantts[i].pid, pid_gantts[i].gantt, 0, max_time);
        free(pid_gantts[i].gantt);
    }

    free(pid_gantts);

    printf("*****Gantt Chart End*****\n\n");
}

int main() {
    // Example usage
    executed_node nodes[] = {
        {4, 0, 3}, {1, 3, 5}, {4, 5, 7}, {5, 7, 8}, {3, 8, 9}, {7, 9, 11},
        {4, 11, 13}, {1, 13, 15}, {5, 15, 17}, {3, 17, 19}, {7, 19, 21},
        {4, 21, 22}, {1, 22, 24}, {5, 24, 26}, {3, 26, 28}, {7, 28, 29}, {3, 29, 32}
    };

    result res = {nodes, 17};

    print_gantt_chart(&res);

    return 0;
}